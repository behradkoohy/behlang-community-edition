-----------------------------------------------------------------------------
Info file generated by Happy Version 1.19.12 from Grammar.y
-----------------------------------------------------------------------------

state 36 contains 2 shift/reduce conflicts.

terminal '->' is unused

-----------------------------------------------------------------------------
Grammar
-----------------------------------------------------------------------------
	%start_parseLambda -> Expr                         (0)
	Expr -> bool                                       (1)
	Expr -> Term                                       (2)
	Expr -> Expr '<' Term                              (3)
	Expr -> Expr '+' Term                              (4)
	Expr -> if Expr then Expr else Expr                (5)
	Expr -> let '(' Factor ':' Type ')' '=' Expr in Expr   (6)
	Expr -> '\\' '(' Factor ':' Type ')' Expr          (7)
	Term -> Factor                                     (8)
	Factor -> int                                      (9)
	Factor -> var                                      (10)
	Factor -> '(' Expr ')'                             (11)
	Type -> Int                                        (12)
	Type -> Bool                                       (13)

-----------------------------------------------------------------------------
Terminals
-----------------------------------------------------------------------------
	int            { TInt $$ }
	bool           { TBool $$ }
	'<'            { TLThan }
	'+'            { TAdd }
	if             { TIf }
	else           { TElse }
	then           { TThen }
	let            { TLet }
	in             { TIn }
	'->'           { TFunc }
	'\\'           { TLambda }
	'='            { TEqual }
	var            { TVar $$ }
	'('            { TLParen }
	')'            { TRParen }
	Int            { TIntType }
	Bool           { TBoolType }
	':'            { TColon }

-----------------------------------------------------------------------------
Non-terminals
-----------------------------------------------------------------------------
	%start_parseLambda rule  0
	Expr            rules 1, 2, 3, 4, 5, 6, 7
	Term            rule  8
	Factor          rules 9, 10, 11
	Type            rules 12, 13

-----------------------------------------------------------------------------
States
-----------------------------------------------------------------------------
State 0


	int            shift, and enter state 6
	bool           shift, and enter state 2
	if             shift, and enter state 7
	let            shift, and enter state 8
	'\\'           shift, and enter state 9
	var            shift, and enter state 10
	'('            shift, and enter state 11

	Expr           goto state 3
	Term           goto state 4
	Factor         goto state 5

State 1


	bool           shift, and enter state 2


State 2

	Expr -> bool .                                      (rule 1)

	'<'            reduce using rule 1
	'+'            reduce using rule 1
	else           reduce using rule 1
	then           reduce using rule 1
	in             reduce using rule 1
	')'            reduce using rule 1
	%eof           reduce using rule 1


State 3

	%start_parseLambda -> Expr .                        (rule 0)
	Expr -> Expr . '<' Term                             (rule 3)
	Expr -> Expr . '+' Term                             (rule 4)

	'<'            shift, and enter state 16
	'+'            shift, and enter state 17
	%eof           accept


State 4

	Expr -> Term .                                      (rule 2)

	'<'            reduce using rule 2
	'+'            reduce using rule 2
	else           reduce using rule 2
	then           reduce using rule 2
	in             reduce using rule 2
	')'            reduce using rule 2
	%eof           reduce using rule 2


State 5

	Term -> Factor .                                    (rule 8)

	'<'            reduce using rule 8
	'+'            reduce using rule 8
	else           reduce using rule 8
	then           reduce using rule 8
	in             reduce using rule 8
	')'            reduce using rule 8
	%eof           reduce using rule 8


State 6

	Factor -> int .                                     (rule 9)

	'<'            reduce using rule 9
	'+'            reduce using rule 9
	else           reduce using rule 9
	then           reduce using rule 9
	in             reduce using rule 9
	')'            reduce using rule 9
	':'            reduce using rule 9
	%eof           reduce using rule 9


State 7

	Expr -> if . Expr then Expr else Expr               (rule 5)

	int            shift, and enter state 6
	bool           shift, and enter state 2
	if             shift, and enter state 7
	let            shift, and enter state 8
	'\\'           shift, and enter state 9
	var            shift, and enter state 10
	'('            shift, and enter state 11

	Expr           goto state 15
	Term           goto state 4
	Factor         goto state 5

State 8

	Expr -> let . '(' Factor ':' Type ')' '=' Expr in Expr    (rule 6)

	'('            shift, and enter state 14


State 9

	Expr -> '\\' . '(' Factor ':' Type ')' Expr         (rule 7)

	'('            shift, and enter state 13


State 10

	Factor -> var .                                     (rule 10)

	'<'            reduce using rule 10
	'+'            reduce using rule 10
	else           reduce using rule 10
	then           reduce using rule 10
	in             reduce using rule 10
	')'            reduce using rule 10
	':'            reduce using rule 10
	%eof           reduce using rule 10


State 11

	Factor -> '(' . Expr ')'                            (rule 11)

	int            shift, and enter state 6
	bool           shift, and enter state 2
	if             shift, and enter state 7
	let            shift, and enter state 8
	'\\'           shift, and enter state 9
	var            shift, and enter state 10
	'('            shift, and enter state 11

	Expr           goto state 12
	Term           goto state 4
	Factor         goto state 5

State 12

	Expr -> Expr . '<' Term                             (rule 3)
	Expr -> Expr . '+' Term                             (rule 4)
	Factor -> '(' Expr . ')'                            (rule 11)

	'<'            shift, and enter state 16
	'+'            shift, and enter state 17
	')'            shift, and enter state 23


State 13

	Expr -> '\\' '(' . Factor ':' Type ')' Expr         (rule 7)

	int            shift, and enter state 6
	var            shift, and enter state 10
	'('            shift, and enter state 11

	Factor         goto state 22

State 14

	Expr -> let '(' . Factor ':' Type ')' '=' Expr in Expr    (rule 6)

	int            shift, and enter state 6
	var            shift, and enter state 10
	'('            shift, and enter state 11

	Factor         goto state 21

State 15

	Expr -> Expr . '<' Term                             (rule 3)
	Expr -> Expr . '+' Term                             (rule 4)
	Expr -> if Expr . then Expr else Expr               (rule 5)

	'<'            shift, and enter state 16
	'+'            shift, and enter state 17
	then           shift, and enter state 20


State 16

	Expr -> Expr '<' . Term                             (rule 3)

	int            shift, and enter state 6
	var            shift, and enter state 10
	'('            shift, and enter state 11

	Term           goto state 19
	Factor         goto state 5

State 17

	Expr -> Expr '+' . Term                             (rule 4)

	int            shift, and enter state 6
	var            shift, and enter state 10
	'('            shift, and enter state 11

	Term           goto state 18
	Factor         goto state 5

State 18

	Expr -> Expr '+' Term .                             (rule 4)

	'<'            reduce using rule 4
	'+'            reduce using rule 4
	else           reduce using rule 4
	then           reduce using rule 4
	in             reduce using rule 4
	')'            reduce using rule 4
	%eof           reduce using rule 4


State 19

	Expr -> Expr '<' Term .                             (rule 3)

	'<'            reduce using rule 3
	'+'            reduce using rule 3
	else           reduce using rule 3
	then           reduce using rule 3
	in             reduce using rule 3
	')'            reduce using rule 3
	%eof           reduce using rule 3


State 20

	Expr -> if Expr then . Expr else Expr               (rule 5)

	int            shift, and enter state 6
	bool           shift, and enter state 2
	if             shift, and enter state 7
	let            shift, and enter state 8
	'\\'           shift, and enter state 9
	var            shift, and enter state 10
	'('            shift, and enter state 11

	Expr           goto state 26
	Term           goto state 4
	Factor         goto state 5

State 21

	Expr -> let '(' Factor . ':' Type ')' '=' Expr in Expr    (rule 6)

	':'            shift, and enter state 25


State 22

	Expr -> '\\' '(' Factor . ':' Type ')' Expr         (rule 7)

	':'            shift, and enter state 24


State 23

	Factor -> '(' Expr ')' .                            (rule 11)

	'<'            reduce using rule 11
	'+'            reduce using rule 11
	else           reduce using rule 11
	then           reduce using rule 11
	in             reduce using rule 11
	')'            reduce using rule 11
	':'            reduce using rule 11
	%eof           reduce using rule 11


State 24

	Expr -> '\\' '(' Factor ':' . Type ')' Expr         (rule 7)

	Int            shift, and enter state 29
	Bool           shift, and enter state 30

	Type           goto state 31

State 25

	Expr -> let '(' Factor ':' . Type ')' '=' Expr in Expr    (rule 6)

	Int            shift, and enter state 29
	Bool           shift, and enter state 30

	Type           goto state 28

State 26

	Expr -> Expr . '<' Term                             (rule 3)
	Expr -> Expr . '+' Term                             (rule 4)
	Expr -> if Expr then Expr . else Expr               (rule 5)

	'<'            shift, and enter state 16
	'+'            shift, and enter state 17
	else           shift, and enter state 27


State 27

	Expr -> if Expr then Expr else . Expr               (rule 5)

	int            shift, and enter state 6
	bool           shift, and enter state 2
	if             shift, and enter state 7
	let            shift, and enter state 8
	'\\'           shift, and enter state 9
	var            shift, and enter state 10
	'('            shift, and enter state 11

	Expr           goto state 34
	Term           goto state 4
	Factor         goto state 5

State 28

	Expr -> let '(' Factor ':' Type . ')' '=' Expr in Expr    (rule 6)

	')'            shift, and enter state 33


State 29

	Type -> Int .                                       (rule 12)

	')'            reduce using rule 12


State 30

	Type -> Bool .                                      (rule 13)

	')'            reduce using rule 13


State 31

	Expr -> '\\' '(' Factor ':' Type . ')' Expr         (rule 7)

	')'            shift, and enter state 32


State 32

	Expr -> '\\' '(' Factor ':' Type ')' . Expr         (rule 7)

	int            shift, and enter state 6
	bool           shift, and enter state 2
	if             shift, and enter state 7
	let            shift, and enter state 8
	'\\'           shift, and enter state 9
	var            shift, and enter state 10
	'('            shift, and enter state 11

	Expr           goto state 36
	Term           goto state 4
	Factor         goto state 5

State 33

	Expr -> let '(' Factor ':' Type ')' . '=' Expr in Expr    (rule 6)

	'='            shift, and enter state 35


State 34

	Expr -> Expr . '<' Term                             (rule 3)
	Expr -> Expr . '+' Term                             (rule 4)
	Expr -> if Expr then Expr else Expr .               (rule 5)

	'<'            shift, and enter state 16
	'+'            shift, and enter state 17
	else           reduce using rule 5
	then           reduce using rule 5
	in             reduce using rule 5
	')'            reduce using rule 5
	%eof           reduce using rule 5


State 35

	Expr -> let '(' Factor ':' Type ')' '=' . Expr in Expr    (rule 6)

	int            shift, and enter state 6
	bool           shift, and enter state 2
	if             shift, and enter state 7
	let            shift, and enter state 8
	'\\'           shift, and enter state 9
	var            shift, and enter state 10
	'('            shift, and enter state 11

	Expr           goto state 37
	Term           goto state 4
	Factor         goto state 5

State 36

	Expr -> Expr . '<' Term                             (rule 3)
	Expr -> Expr . '+' Term                             (rule 4)
	Expr -> '\\' '(' Factor ':' Type ')' Expr .         (rule 7)

	'<'            shift, and enter state 16
			(reduce using rule 7)

	'+'            shift, and enter state 17
			(reduce using rule 7)

	else           reduce using rule 7
	then           reduce using rule 7
	in             reduce using rule 7
	')'            reduce using rule 7
	%eof           reduce using rule 7


State 37

	Expr -> Expr . '<' Term                             (rule 3)
	Expr -> Expr . '+' Term                             (rule 4)
	Expr -> let '(' Factor ':' Type ')' '=' Expr . in Expr    (rule 6)

	'<'            shift, and enter state 16
	'+'            shift, and enter state 17
	in             shift, and enter state 38


State 38

	Expr -> let '(' Factor ':' Type ')' '=' Expr in . Expr    (rule 6)

	int            shift, and enter state 6
	bool           shift, and enter state 2
	if             shift, and enter state 7
	let            shift, and enter state 8
	'\\'           shift, and enter state 9
	var            shift, and enter state 10
	'('            shift, and enter state 11

	Expr           goto state 39
	Term           goto state 4
	Factor         goto state 5

State 39

	Expr -> Expr . '<' Term                             (rule 3)
	Expr -> Expr . '+' Term                             (rule 4)
	Expr -> let '(' Factor ':' Type ')' '=' Expr in Expr .    (rule 6)

	'<'            shift, and enter state 16
	'+'            shift, and enter state 17
	else           reduce using rule 6
	then           reduce using rule 6
	in             reduce using rule 6
	')'            reduce using rule 6
	%eof           reduce using rule 6


-----------------------------------------------------------------------------
Grammar Totals
-----------------------------------------------------------------------------
Number of rules: 14
Number of terminals: 18
Number of non-terminals: 5
Number of states: 40
